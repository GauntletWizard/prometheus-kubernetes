{
    "apiVersion": "v1",
    "data": {
        "prometheus.yml": "# A scrape configuration for running Prometheus on a Kubernetes cluster.\n# This uses separate scrape configs for cluster components (i.e. API server, node)\n# and services to allow each to use different authentication configs.\n#\n# Kubernetes labels will be added as Prometheus labels on metrics via the\n# `labelmap` relabeling action.\n\nrule_files:\n  - \"/etc/prometheus-rules/*.rules\"\n\n# Scrape config for cluster components.\nscrape_configs:\n# etcd is living outside of our cluster and we configure\n# it directly.\n#- job_name: 'etcd'\n#  static_configs:\n#  - targets:\n#{% for host in groups['etcd'] %}\n#    - {{ hostvars[host]['ansible_' + etcd_interface].ipv4.address }}:{{ etcd_client_port }}\n#{% endfor %}\n#  tls_config:\n#    ca_file: /etc/etcd/ssl/ca.pem\n#    cert_file: /etc/etcd/ssl/client.pem\n#    key_file: /etc/etcd/ssl/client-key.pem\n#  scheme: https\n# Dynamic etcd rule, which helps to avoid ansible jinja2 templates\n# In order to make it work as expected it is necessary to add kubelet into all etcd nodes (and set them unschedulable if necessary)\n# Also you have to mount proper TLS keypairs in case when your etcd cluster is protected by TLS auth\n- job_name: 'etcd'\n  scheme: https\n  tls_config:\n    ca_file: /etc/etcd/ssl/ca.pem\n    cert_file: /etc/etcd/ssl/client.pem\n    key_file: /etc/etcd/ssl/client-key.pem\n  kubernetes_sd_configs:\n  - api_servers:\n    - https://kubernetes.default.svc\n    in_cluster: true\n    role: node\n  relabel_configs:\n  - action: labelmap\n    regex: __meta_kubernetes_node_label_(.+)\n  - source_labels: [__address__]\n    regex: '(.*):10250'\n    replacement: '${1}:2379'\n    target_label: __address__\n\n- job_name: 'kubernetes-cluster'\n  # Default to scraping over https. If required, just disable this or change to\n  # `http`.\n  scheme: https\n  # This TLS \u0026 bearer token file config is used to connect to the actual scrape\n  # endpoints for cluster components. This is separate to discovery auth\n  # configuration (`in_cluster` below) because discovery \u0026 scraping are two\n  # separate concerns in Prometheus.\n  tls_config:\n    ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n    # If your node certificates are self-signed or use a different CA to the\n    # master CA, then disable certificate verification below. Note that\n    # certificate verification is an integral part of a secure infrastructure\n    # so this should only be disabled in a controlled environment. You can\n    # disable certificate verification by uncommenting the line below.\n    #\n    # insecure_skip_verify: true\n  bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token\n\n  kubernetes_sd_configs:\n  - api_servers:\n    - https://kubernetes.default.svc\n    in_cluster: true\n    role: apiserver\n\n- job_name: 'kubernetes-cadvisor'\n\n  # Default to scraping over https. If required, just disable this or change to\n  # `http`.\n  scheme: http\n\n  # This TLS \u0026 bearer token file config is used to connect to the actual scrape\n  # endpoints for cluster components. This is separate to discovery auth\n  # configuration (`in_cluster` below) because discovery \u0026 scraping are two\n  # separate concerns in Prometheus.\n  #tls_config:\n  #  ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n    # If your node certificates are self-signed or use a different CA to the\n    # master CA, then disable certificate verification below. Note that\n    # certificate verification is an integral part of a secure infrastructure\n    # so this should only be disabled in a controlled environment. You can\n    # disable certificate verification by uncommenting the line below.\n    #\n    # insecure_skip_verify: true\n  #bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token\n\n  kubernetes_sd_configs:\n  - api_servers:\n    - https://kubernetes.default.svc\n    in_cluster: true\n    role: node\n\n  relabel_configs:\n  - action: labelmap\n    regex: __meta_kubernetes_node_label_(.+)\n  # Use cadvisor 4194 port\n  - source_labels: [__address__]\n    regex: '(.*):10250'\n    replacement: '${1}:4194'\n    target_label: __address__\n\n  # Backward compatibility for Kubernetes 1.3 dashboards\n  metric_relabel_configs:\n  - source_labels: [io_kubernetes_container_name,container_name]\n    action: replace\n    regex: (.*);(.*)\n    replacement: '${1}${2}'\n    target_label: io_kubernetes_container_name\n  - source_labels: [kubernetes_pod_name,pod_name]\n    action: replace\n    regex: (.*);(.*)\n    replacement: '${1}${2}'\n    target_label: kubernetes_pod_name\n  - source_labels: [kubernetes_pod_name]\n    action: replace\n    target_label: io_kubernetes_pod_name\n\n- job_name: 'kubernetes-nodes'\n\n  # Default to scraping over https. If required, just disable this or change to\n  # `http`.\n  scheme: http\n\n  # This TLS \u0026 bearer token file config is used to connect to the actual scrape\n  # endpoints for cluster components. This is separate to discovery auth\n  # configuration (`in_cluster` below) because discovery \u0026 scraping are two\n  # separate concerns in Prometheus.\n  #tls_config:\n  #  ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n    # If your node certificates are self-signed or use a different CA to the\n    # master CA, then disable certificate verification below. Note that\n    # certificate verification is an integral part of a secure infrastructure\n    # so this should only be disabled in a controlled environment. You can\n    # disable certificate verification by uncommenting the line below.\n    #\n    # insecure_skip_verify: true\n  #bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token\n\n  kubernetes_sd_configs:\n  - api_servers:\n    - https://kubernetes.default.svc\n    in_cluster: true\n    role: node\n\n  relabel_configs:\n  - action: labelmap\n    regex: __meta_kubernetes_node_label_(.+)\n  # Use insecure read-only HTTP 10255 port\n  # More info is here: https://github.com/kayrus/kubelet-exploit\n  - source_labels: [__address__]\n    regex: '(.*):10250'\n    replacement: '${1}:10255'\n    target_label: __address__\n\n  # Backward compatibility for Kubernetes 1.3 dashboards\n  metric_relabel_configs:\n  - source_labels: [io_kubernetes_container_name,container_name]\n    action: replace\n    regex: (.*);(.*)\n    replacement: '${1}${2}'\n    target_label: io_kubernetes_container_name\n  - source_labels: [kubernetes_pod_name,pod_name]\n    action: replace\n    regex: (.*);(.*)\n    replacement: '${1}${2}'\n    target_label: kubernetes_pod_name\n  - source_labels: [kubernetes_pod_name]\n    action: replace\n    target_label: io_kubernetes_pod_name\n\n- job_name: 'kubernetes-node-exporter'\n  tls_config:\n    ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n  bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token\n  kubernetes_sd_configs:\n  - api_servers:\n    - https://kubernetes.default.svc\n    in_cluster: true\n    role: node\n\n  relabel_configs:\n  - action: labelmap\n    regex: __meta_kubernetes_node_label_(.+)\n  - source_labels: [__meta_kubernetes_role]\n    action: replace\n    target_label: kubernetes_role\n  - source_labels: [__address__]\n    regex: '(.*):10250'\n    replacement: '${1}:9100'\n    target_label: __address__\n  - source_labels: [__meta_kubernetes_node_label_kubernetes_io_hostname]\n    target_label: __instance__\n  # set \"name\" value to \"job\"\n  - source_labels: [job]\n    regex: 'kubernetes-(.*)'\n    replacement: '${1}'\n    target_label: name\n\n# Scrape config for service endpoints.\n#\n# The relabeling allows the actual service scrape endpoint to be configured\n# via the following annotations:\n#\n# * `prometheus.io/scrape`: Only scrape services that have a value of `true`\n# * `prometheus.io/scheme`: If the metrics endpoint is secured then you will need\n# to set this to `https` \u0026 most likely set the `tls_config` of the scrape config.\n# * `prometheus.io/path`: If the metrics path is not `/metrics` override this.\n# * `prometheus.io/port`: If the metrics are exposed on a different port to the\n# service then set this appropriately.\n- job_name: 'kubernetes-service-endpoints'\n\n  kubernetes_sd_configs:\n  - api_servers:\n    - 'https://kubernetes.default.svc'\n    in_cluster: true\n    role: endpoint\n\n  relabel_configs:\n  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape]\n    action: keep\n    regex: true\n  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scheme]\n    action: replace\n    target_label: __scheme__\n    regex: (https?)\n  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_path]\n    action: replace\n    target_label: __metrics_path__\n    regex: (.+)\n  - source_labels: [__address__, __meta_kubernetes_service_annotation_prometheus_io_port]\n    action: replace\n    target_label: __address__\n    regex: (.+)(?::\\d+);(\\d+)\n    replacement: $1:$2\n  - action: labelmap\n    regex: __meta_kubernetes_service_label_(.+)\n  - source_labels: [__meta_kubernetes_service_namespace]\n    action: replace\n    target_label: kubernetes_namespace\n  - source_labels: [__meta_kubernetes_service_name]\n    action: replace\n    target_label: kubernetes_name\n\n# Example scrape config for probing services via the Blackbox Exporter.\n#\n# The relabeling allows the actual service scrape endpoint to be configured\n# via the following annotations:\n#\n# * `prometheus.io/probe`: Only probe services that have a value of `true`\n- job_name: 'kubernetes-services'\n\n  metrics_path: /probe\n  params:\n    module: [http_2xx]\n\n  kubernetes_sd_configs:\n  - api_servers:\n    - 'https://kubernetes.default.svc'\n    in_cluster: true\n    role: service\n\n  relabel_configs:\n  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_probe]\n    action: keep\n    regex: true\n  - source_labels: [__address__]\n    target_label: __param_target\n  - target_label: __address__\n    replacement: blackbox\n  - source_labels: [__param_target]\n    target_label: instance\n  - action: labelmap\n    regex: __meta_kubernetes_service_label_(.+)\n  - source_labels: [__meta_kubernetes_service_namespace]\n    target_label: kubernetes_namespace\n  - source_labels: [__meta_kubernetes_service_name]\n    target_label: kubernetes_name\n\n# Example scrape config for pods\n#\n# The relabeling allows the actual pod scrape endpoint to be configured via the\n# following annotations:\n#\n# * `prometheus.io/scrape`: Only scrape pods that have a value of `true`\n# * `prometheus.io/path`: If the metrics path is not `/metrics` override this.\n# * `prometheus.io/port`: Scrape the pod on the indicated port instead of the default of `9102`.\n- job_name: 'kubernetes-pods'\n\n  kubernetes_sd_configs:\n  - api_servers:\n    - 'https://kubernetes.default.svc'\n    in_cluster: true\n    role: pod\n\n  relabel_configs:\n  - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]\n    action: keep\n    regex: true\n  - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]\n    action: replace\n    target_label: __metrics_path__\n    regex: (.+)\n  - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]\n    action: replace\n    regex: (.+):(?:\\d+);(\\d+)\n    replacement: ${1}:${2}\n    target_label: __address__\n  - action: labelmap\n    regex: __meta_kubernetes_pod_label_(.+)\n  - source_labels: [__meta_kubernetes_pod_namespace]\n    action: replace\n    target_label: kubernetes_namespace\n  - source_labels: [__meta_kubernetes_pod_name]\n    action: replace\n    target_label: kubernetes_pod_name"
    },
    "kind": "ConfigMap",
    "metadata": {
        "name": "prometheus-configmap",
        "namespace": "default"
    }
}
