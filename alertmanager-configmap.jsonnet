{
    "apiVersion": "v1",
    "data": {
        "config.yml": "global:\n  # ResolveTimeout is the time after which an alert is declared resolved\n  # if it has not been updated.\n  resolve_timeout: 5m\n\n  # The smarthost and SMTP sender used for mail notifications.\n  smtp_smarthost: 'smtp.gmail.com:587'\n  smtp_from: 'foo@bar.com'\n  smtp_auth_username: 'foo@bar.com'\n  smtp_auth_password: 'barfoo'\n\n  # The API URL to use for Slack notifications.\n  slack_api_url: 'https://hooks.slack.com/services/abc123'\n\n  # # The auth token for Hipchat.\n  # hipchat_auth_token: '1234556789'\n  #\n  # # Alternative host for Hipchat.\n  # hipchat_url: 'https://hipchat.foobar.org/'\n\n# # The directory from which notification templates are read.\ntemplates:\n- '/etc/alertmanager-templates/*.tmpl'\n\n# The root route on which each incoming alert enters.\nroute:\n\n  # The labels by which incoming alerts are grouped together. For example,\n  # multiple alerts coming in for cluster=A and alertname=LatencyHigh would\n  # be batched into a single group.\n\n  group_by: ['alertname', 'cluster', 'service']\n\n  # When a new group of alerts is created by an incoming alert, wait at\n  # least 'group_wait' to send the initial notification.\n  # This way ensures that you get multiple alerts for the same group that start\n  # firing shortly after another are batched together on the first\n  # notification.\n\n  group_wait: 30s\n\n  # When the first notification was sent, wait 'group_interval' to send a batch\n  # of new alerts that started firing for that group.\n\n  group_interval: 5m\n\n  # If an alert has successfully been sent, wait 'repeat_interval' to\n  # resend them.\n\n  #repeat_interval: 1m\n  repeat_interval: 15m\n\n  # A default receiver\n\n  # If an alert isn't caught by a route, send it to default.\n  receiver: default\n\n  # All the above attributes are inherited by all child routes and can\n  # overwritten on each.\n\n  # The child route trees.\n  routes:\n  # Send severity=slack alerts to slack.\n  - match:\n      severity: slack\n    receiver: slack_alert\n  - match:\n      severity: email\n    receiver: slack_alert\n#   receiver: email_alert\n\nreceivers:\n- name: 'default'\n  slack_configs:\n  - channel: '#devops'\n    text: '\u003c!channel\u003e{{ template \"slack.devops.text\" . }}'\n    send_resolved: true\n\n- name: 'slack_alert'\n  slack_configs:\n  - channel: '#devops'\n    send_resolved: true\n\n    # # Whether or not to notify about resolved alerts.\n    # send_resolved: true\n    #\n    # # The Slack webhook URL.\n    # [ api_url: \u003cstring\u003e | default = global.slack_api_url ]\n    #\n    # # The channel or user to send notifications to.\n    # channel: \u003ctmpl_string\u003e\n    #\n    # # API request data as defined by the Slack webhook API.\n    # [ color: \u003ctmpl_string\u003e | default = '{{ if eq .Status \"firing\" }}danger{{ else }}good{{ end }}' ]\n    # [ username: \u003ctmpl_string\u003e | default = '{{ template \"slack.default.username\" . }}'\n    # [ title: \u003ctmpl_string\u003e | default = '{{ template \"slack.default.title\" . }}' ]\n    # [ title_link: \u003ctmpl_string\u003e | default = '{{ template \"slack.default.titlelink\" . }}' ]\n    # [ icon_emoji: \u003ctmpl_string\u003e ]\n    # [ pretext: \u003ctmpl_string\u003e | default = '{{ template \"slack.default.pretext\" . }}' ]\n    # [ text: \u003ctmpl_string\u003e | default = '{{ template \"slack.default.text\" . }}' ]\n    # [ fallback: \u003ctmpl_string\u003e | default = '{{ template \"slack.default.fallback\" . }}' ]\n\n- name: 'email_alert'\n  email_configs:\n  - to: 'foo@bar.com'\n\n\n#\n#\n#\n# global:\n#   # The smarthost and SMTP sender used for mail notifications.\n#   smtp_smarthost: 'localhost:25'\n#   smtp_from: 'alertmanager@example.org'\n#   smtp_auth_username: 'alertmanager'\n#   smtp_auth_password: 'password'\n#   # The auth token for Hipchat.\n#   hipchat_auth_token: '1234556789'\n#   # Alternative host for Hipchat.\n#   hipchat_url: 'https://hipchat.foobar.org/'\n#\n# # The directory from which notification templates are read.\n# templates:\n# - '/etc/alertmanager/template/*.tmpl'\n#\n# # The root route on which each incoming alert enters.\n# route:\n#   # The labels by which incoming alerts are grouped together. For example,\n#   # multiple alerts coming in for cluster=A and alertname=LatencyHigh would\n#   # be batched into a single group.\n#   group_by: ['alertname', 'cluster', 'service']\n#\n#   # When a new group of alerts is created by an incoming alert, wait at\n#   # least 'group_wait' to send the initial notification.\n#   # This way ensures that you get multiple alerts for the same group that start\n#   # firing shortly after another are batched together on the first\n#   # notification.\n#   group_wait: 30s\n#\n#   # When the first notification was sent, wait 'group_interval' to send a batch\n#   # of new alerts that started firing for that group.\n#   group_interval: 5m\n#\n#   # If an alert has successfully been sent, wait 'repeat_interval' to\n#   # resend them.\n#   repeat_interval: 3h\n#\n#   # A default receiver\n#   receiver: team-X-mails\n#\n#   # All the above attributes are inherited by all child routes and can\n#   # overwritten on each.\n#\n#   # The child route trees.\n#   routes:\n#   # This routes performs a regular expression match on alert labels to\n#   # catch alerts that are related to a list of services.\n#   - match_re:\n#       service: ^(foo1|foo2|baz)$\n#     receiver: team-X-mails\n#     # The service has a sub-route for critical alerts, any alerts\n#     # that do not match, i.e. severity != critical, fall-back to the\n#     # parent node and are sent to 'team-X-mails'\n#     routes:\n#     - match:\n#         severity: critical\n#       receiver: team-X-pager\n#   - match:\n#       service: files\n#     receiver: team-Y-mails\n#\n#     routes:\n#     - match:\n#         severity: critical\n#       receiver: team-Y-pager\n#\n#   # This route handles all alerts coming from a database service. If there's\n#   # no team to handle it, it defaults to the DB team.\n#   - match:\n#       service: database\n#     receiver: team-DB-pager\n#     # Also group alerts by affected database.\n#     group_by: [alertname, cluster, database]\n#     routes:\n#     - match:\n#         owner: team-X\n#       receiver: team-X-pager\n#     - match:\n#         owner: team-Y\n#       receiver: team-Y-pager\n#\n#\n# # Inhibition rules allow to mute a set of alerts given that another alert is\n# # firing.\n# # We use this to mute any warning-level notifications if the same alert is\n# # already critical.\n# inhibit_rules:\n# - source_match:\n#     severity: 'critical'\n#   target_match:\n#     severity: 'warning'\n#   # Apply inhibition if the alertname is the same.\n#   equal: ['alertname', 'cluster', 'service']\n#\n#\n# receivers:\n# - name: 'team-X-mails'\n#   email_configs:\n#   - to: 'team-X+alerts@example.org'\n#\n# - name: 'team-X-pager'\n#   email_configs:\n#   - to: 'team-X+alerts-critical@example.org'\n#   pagerduty_configs:\n#   - service_key: \u003cteam-X-key\u003e\n#\n# - name: 'team-Y-mails'\n#   email_configs:\n#   - to: 'team-Y+alerts@example.org'\n#\n# - name: 'team-Y-pager'\n#   pagerduty_configs:\n#   - service_key: \u003cteam-Y-key\u003e\n#\n# - name: 'team-DB-pager'\n#   pagerduty_configs:\n#   - service_key: \u003cteam-DB-key\u003e\n# - name: 'team-X-hipchat'\n#   hipchat_configs:\n#   - auth_token: \u003cauth_token\u003e\n#     room_id: 85\n#     message_format: html\n#     notify: true"
    },
    "kind": "ConfigMap",
    "metadata": {
        "name": "alertmanager",
        "namespace": "default"
    }
}
